<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kelvin's Sprite Creator</title>
    <style>
        :root {
            --bg-color: #2b2b2b;
            --panel-bg: #383838;
            --accent: #5c87ff;
            --text: #e0e0e0;
            --border: #555;
            --success: #28a745;
            --warning: #ffc107;
        }
        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: var(--bg-color);
            color: var(--text);
            display: flex;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none; 
        }
        
        /* Layout */
        .sidebar {
            width: 280px;
            background-color: var(--panel-bg);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            border-right: 1px solid var(--border);
            overflow-y: auto;
        }
        
        /* NEW SIDEBAR TITLE STYLE */
        .app-title {
            margin: 0 0 5px 0;
            font-size: 1.4em;
            color: #fff;
            text-align: center;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1px;
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 6px;
            border: 1px solid var(--border);
            text-shadow: 2px 2px 0 #000;
        }

        .main-area {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            background-image: 
                linear-gradient(45deg, #222 25%, transparent 25%), 
                linear-gradient(-45deg, #222 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #222 75%), 
                linear-gradient(-45deg, transparent 75%, #222 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            overflow: hidden;
        }

        h3 { margin-bottom: 10px; font-size: 1.1em; border-bottom: 1px solid #555; padding-bottom: 5px; }

        /* Tools */
        .tool-group {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
        }
        button {
            background: #4a4a4a;
            border: 1px solid var(--border);
            color: white;
            padding: 8px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.9em;
            transition: 0.2s;
            position: relative;
        }
        button:hover { background: #5a5a5a; }
        button:active { transform: translateY(1px); }
        button.active {
            background: var(--accent);
            border-color: #7aa0ff;
        }

        /* Brush Size Control */
        .brush-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            background: rgba(0,0,0,0.2);
            padding: 8px;
            border-radius: 4px;
        }
        
        /* Import Section Styles */
        .import-box {
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 4px;
            border: 1px dashed #666;
            text-align: center;
        }
        .btn-search { 
            background: var(--warning); 
            color: #222; 
            font-weight: bold; 
            border: none; 
            width: 100%; 
            margin-bottom: 5px; 
            display: block; 
            text-align: center;
            text-decoration: none;
            padding: 8px 0;
            border-radius: 4px;
            font-size: 0.9em;
            box-sizing: border-box;
        }

        /* Color Picker Section */
        .color-controls { display: flex; flex-direction: column; gap: 8px; }
        .current-color-row { display: flex; gap: 8px; align-items: center; }
        #drag-source {
            width: 40px; height: 40px; border: 2px solid white; border-radius: 4px; cursor: grab;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        .input-group { flex: 1; display: flex; flex-direction: column; gap: 2px; }
        input[type="color"] { width: 100%; height: 20px; border: none; cursor: pointer; background: none; padding: 0; }
        input[type="text"] {
            background: #222; border: 1px solid var(--border); color: white;
            padding: 4px; border-radius: 4px; text-transform: uppercase; font-family: monospace;
            width: 100%; box-sizing: border-box;
        }
        .palette {
            display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px;
            margin-top: 10px; padding: 5px; background: rgba(0,0,0,0.1); border-radius: 4px;
        }
        .swatch {
            height: 35px; border-radius: 4px; border: 1px solid var(--border); cursor: pointer; transition: transform 0.1s;
        }
        .swatch.drag-over { border: 2px dashed white; opacity: 0.5; }

        /* Canvas */
        canvas {
            image-rendering: pixelated;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background: white;
            /* We hide default cursor to show our custom crosshair */
            cursor: none; 
        }

        /* Frames & Preview */
        .preview-box {
            background: #222; border: 1px solid var(--border); padding: 10px; text-align: center; border-radius: 4px;
        }
        .frame-list {
            display: flex; gap: 5px; overflow-x: auto; padding-bottom: 5px; min-height: 44px;
        }
        .frame-thumb {
            width: 40px; height: 40px; border: 2px solid var(--border); image-rendering: pixelated;
            background: #fff; flex-shrink: 0; cursor: pointer;
        }
        .frame-thumb.selected { border-color: var(--accent); }

        /* General Inputs */
        .control-row { display: flex; justify-content: space-between; align-items: center; font-size: 0.85em; }
        input[type="number"] { width: 50px; background: #222; border: 1px solid var(--border); color: white; padding: 4px; border-radius: 4px; }
        #file-input { display: none; }
        
        #paste-overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(92, 135, 255, 0.8);
            display: none; justify-content: center; align-items: center; color: white; font-size: 2em;
            font-weight: bold; pointer-events: none; z-index: 100;
        }
    </style>
</head>
<body>

    <div id="paste-overlay">Processing Image...</div>

    <div class="sidebar">
        <h1 class="app-title">Kelvin's<br>Sprite Creator</h1>

        <div>
            <h3>Tools</h3>
            <div class="tool-group">
                <button id="btn-pen" class="active" onclick="setTool('pen')" title="Pen (P)">‚úèÔ∏è</button>
                <button id="btn-eraser" onclick="setTool('eraser')" title="Eraser (E)">üßπ</button>
                <button id="btn-picker" onclick="setTool('picker')" title="Picker (I)">üß™</button>
                <button onclick="clearCanvas()" title="Clear Frame (Del)">‚ùå</button>
            </div>
            
            <div class="brush-control">
                <span style="font-size:0.8em; color:#aaa;">Size:</span>
                <input type="range" id="brush-slider" min="1" max="8" value="1" style="flex:1" title="Brush Size">
                <span id="brush-display" style="width:15px; text-align:center; font-size:0.9em;">1</span>
            </div>
            <div style="display:flex; gap:5px; margin-top:5px;">
                <button style="flex:1" onclick="undo()" title="Undo (Ctrl+Z)">‚Ü©Ô∏è Undo</button>
                <button style="flex:1" onclick="redo()" title="Redo (Ctrl+Y)">‚Ü™Ô∏è Redo</button>
            </div>
        </div>

        <div>
            <h3>üåê Import</h3>
            <div class="import-box">
                <a href="https://www.google.com/search?q=pixel+art+sprite+simple+transparent&tbm=isch" target="_blank" class="btn-search" title="Search">üîç Search Online</a>
                <div style="font-size:0.8em; color:#aaa; margin:5px 0;">Paste images with <strong>Ctrl+V</strong></div>
                <button class="btn-upload" onclick="document.getElementById('file-input').click()">üìÅ Upload</button>
                <input type="file" id="file-input" accept="image/*" onchange="handleFileUpload(this)">
            </div>
        </div>

        <div class="color-section">
            <h3>Palette</h3>
            <div class="color-controls">
                <div class="current-color-row">
                    <div id="drag-source" draggable="true" title="Drag to Palette"></div>
                    <div class="input-group">
                        <input type="text" id="hex-input" value="#000000">
                        <input type="color" id="color-picker" value="#000000">
                    </div>
                </div>
                <div class="palette" id="palette-container"></div>
            </div>
        </div>

        <div>
            <h3>Animation</h3>
            <div class="preview-box">
                <canvas id="preview-canvas" width="64" height="64"></canvas>
                <div class="control-row" style="margin-top:5px;">
                    <label>FPS: <span id="fps-display">8</span></label>
                    <input type="range" id="fps-slider" min="1" max="24" value="8">
                </div>
                <button id="btn-play" style="width:100%; margin-top:5px;">‚èØÔ∏è Play/Pause</button>
            </div>
            <h4 style="margin: 10px 0 5px;">Frames</h4>
            <div class="frame-list" id="frame-list"></div>
            <div style="margin-top:5px; display:flex; gap:5px;">
                <button onclick="addFrame()" style="flex:1;">+ Add</button>
                <button onclick="duplicateFrame()" style="flex:1;">Copy</button>
                <button onclick="deleteFrame()" style="width:30px;">üóëÔ∏è</button>
            </div>
        </div>

        <div>
            <h3>Project</h3>
            <div class="control-row">
                <label>Size:</label>
                <input type="number" id="size-input" value="32" min="8" max="64">
                <button onclick="resizeGrid()">Set</button>
            </div>
            <div style="margin-top:15px; display:flex; gap:5px;">
                <button onclick="exportImage()" style="flex:1;">üíæ PNG</button>
                <button onclick="exportSpriteSheet()" style="flex:1;">üéûÔ∏è Sheet</button>
            </div>
        </div>
    </div>

    <div class="main-area" id="main-area">
        <canvas id="editor-canvas"></canvas>
    </div>

<script>
    const state = {
        width: 32,
        height: 32,
        scale: 16,
        frames: [], 
        currentFrameIndex: 0,
        tool: 'pen', 
        brushSize: 1, 
        color: '#000000',
        palette: ['#000000', '#ffffff', '#ff0000', '#00ff00', '#0000ff', '#ffff00', '#00ffff', '#ff00ff'],
        isDrawing: false,
        isPlaying: true,
        fps: 8,
        previewScale: 4,
        history: [],
        historyIndex: -1,
        mouseX: -1,
        mouseY: -1
    };

    const canvas = document.getElementById('editor-canvas');
    const ctx = canvas.getContext('2d');
    const previewCanvas = document.getElementById('preview-canvas');
    const previewCtx = previewCanvas.getContext('2d');
    const colorInput = document.getElementById('color-picker');
    const hexInput = document.getElementById('hex-input');
    const dragSource = document.getElementById('drag-source');
    const frameList = document.getElementById('frame-list');

    function init() {
        resizeCanvas();
        addFrame(); 
        renderPalette(); 
        startAnimationLoop();
        
        canvas.addEventListener('mousedown', startDraw);
        window.addEventListener('mouseup', endDraw); 
        canvas.addEventListener('mousemove', (e) => {
            trackMouse(e);
            draw(e);
        });
        canvas.addEventListener('mouseleave', () => {
            state.mouseX = -1;
            renderEditor(); 
        });

        window.addEventListener('keydown', handleShortcuts);
        window.addEventListener('paste', handlePaste);

        document.getElementById('fps-slider').addEventListener('input', (e) => {
            state.fps = parseInt(e.target.value);
            document.getElementById('fps-display').innerText = state.fps;
        });
        document.getElementById('btn-play').addEventListener('click', () => state.isPlaying = !state.isPlaying);
        document.getElementById('brush-slider').addEventListener('input', (e) => {
            state.brushSize = parseInt(e.target.value);
            document.getElementById('brush-display').innerText = state.brushSize;
        });

        colorInput.addEventListener('input', (e) => updateColor(e.target.value));
        hexInput.addEventListener('input', (e) => {
            const val = e.target.value;
            const validHex = parseColorString(val);
            if (validHex) updateColor(validHex);
        });
        
        setupDragSource();
        updateColor('#000000');
    }

    function saveHistory() {
        if (state.historyIndex < state.history.length - 1) {
            state.history = state.history.slice(0, state.historyIndex + 1);
        }
        if (state.history.length > 50) {
            state.history.shift();
            state.historyIndex--;
        }
        const currentData = state.frames[state.currentFrameIndex];
        const copy = new ImageData(
            new Uint8ClampedArray(currentData.data),
            currentData.width,
            currentData.height
        );
        state.history.push({
            frameIndex: state.currentFrameIndex,
            data: copy
        });
        state.historyIndex++;
    }

    function undo() {
        if (state.historyIndex >= 0) {
            const hist = state.history[state.historyIndex];
            if(hist.frameIndex === state.currentFrameIndex) {
                 state.frames[state.currentFrameIndex] = new ImageData(
                    new Uint8ClampedArray(hist.data.data),
                    hist.data.width,
                    hist.data.height
                );
                state.historyIndex--;
                renderEditor();
                updateFrameThumb(state.currentFrameIndex);
            } else {
                state.currentFrameIndex = hist.frameIndex;
                state.frames[state.currentFrameIndex] = hist.data; 
                state.historyIndex--;
                renderEditor();
                renderFrameList();
            }
        }
    }

    function redo() {
        if (state.historyIndex < state.history.length - 1) {
            state.historyIndex++;
            const hist = state.history[state.historyIndex];
            state.frames[state.currentFrameIndex] = new ImageData(
                new Uint8ClampedArray(hist.data.data),
                hist.data.width,
                hist.data.height
            );
            renderEditor();
            updateFrameThumb(state.currentFrameIndex);
        }
    }
    
    function commitToHistory() {
        if (state.historyIndex < state.history.length - 1) {
            state.history = state.history.slice(0, state.historyIndex + 1);
        }
        const currentData = state.frames[state.currentFrameIndex];
        const copy = new ImageData(
            new Uint8ClampedArray(currentData.data),
            currentData.width,
            currentData.height
        );
        state.history.push({
            frameIndex: state.currentFrameIndex,
            data: copy
        });
        state.historyIndex++;
    }

    function handleShortcuts(e) {
        if (e.ctrlKey && e.key === 'z') {
            e.preventDefault();
            if(state.historyIndex > 0) {
                state.historyIndex--;
                const hist = state.history[state.historyIndex];
                state.frames[state.currentFrameIndex] = new ImageData(
                    new Uint8ClampedArray(hist.data.data), hist.data.width, hist.data.height
                );
                renderEditor();
                updateFrameThumb(state.currentFrameIndex);
            }
        }
        if ((e.ctrlKey && e.key === 'y') || (e.ctrlKey && e.shiftKey && e.key === 'z')) {
            e.preventDefault();
            if(state.historyIndex < state.history.length - 1) {
                state.historyIndex++;
                const hist = state.history[state.historyIndex];
                state.frames[state.currentFrameIndex] = new ImageData(
                    new Uint8ClampedArray(hist.data.data), hist.data.width, hist.data.height
                );
                renderEditor();
                updateFrameThumb(state.currentFrameIndex);
            }
        }
    }

    function trackMouse(e) {
        const rect = canvas.getBoundingClientRect();
        state.mouseX = Math.floor((e.clientX - rect.left) / state.scale);
        state.mouseY = Math.floor((e.clientY - rect.top) / state.scale);
        renderEditor(); 
    }

    function startDraw(e) {
        if (e.button !== 0) return; 
        state.isDrawing = true;
        draw(e);
    }

    function endDraw() {
        if (state.isDrawing) {
            state.isDrawing = false;
            updateFrameThumb(state.currentFrameIndex);
            commitToHistory(); 
        }
    }

    function draw(e) {
        if (!state.isDrawing) return;
        
        const x = state.mouseX;
        const y = state.mouseY;

        if (x < -state.brushSize || x >= state.width+state.brushSize || y < -state.brushSize || y >= state.height+state.brushSize) return;

        const frameData = state.frames[state.currentFrameIndex];
        
        if (state.tool === 'picker') {
             if(x>=0 && x<state.width && y>=0 && y<state.height) {
                const idx = (y * state.width + x) * 4;
                const r = frameData.data[idx];
                const g = frameData.data[idx+1];
                const b = frameData.data[idx+2];
                const a = frameData.data[idx+3];
                if(a > 0) {
                    const hex = "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
                    updateColor(hex);
                    setTool('pen');
                }
            }
            return;
        }

        const bigint = parseInt(state.color.slice(1), 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;

        const offset = Math.floor(state.brushSize / 2);
        
        for (let ix = 0; ix < state.brushSize; ix++) {
            for (let iy = 0; iy < state.brushSize; iy++) {
                const drawX = x - offset + ix;
                const drawY = y - offset + iy;

                if (drawX >= 0 && drawX < state.width && drawY >= 0 && drawY < state.height) {
                    const idx = (drawY * state.width + drawX) * 4;
                    if (state.tool === 'pen') {
                        frameData.data[idx] = r;
                        frameData.data[idx+1] = g;
                        frameData.data[idx+2] = b;
                        frameData.data[idx+3] = 255;
                    } else if (state.tool === 'eraser') {
                        frameData.data[idx+3] = 0;
                    }
                }
            }
        }

        renderEditor(); 
    }

    function renderEditor() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#ddd';
        for(let y=0; y<state.height; y++) {
            for(let x=0; x<state.width; x++) {
                if((x+y)%2 === 0) ctx.fillRect(x*state.scale, y*state.scale, state.scale, state.scale);
            }
        }

        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = state.width;
        tempCanvas.height = state.height;
        const tempCtx = tempCanvas.getContext('2d');
        if (state.frames[state.currentFrameIndex]) {
            tempCtx.putImageData(state.frames[state.currentFrameIndex], 0, 0);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(tempCanvas, 0, 0, state.width * state.scale, state.height * state.scale);
        }

        ctx.strokeStyle = 'rgba(0,0,0,0.1)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i=0; i<=state.width; i++) {
            ctx.moveTo(i*state.scale, 0);
            ctx.lineTo(i*state.scale, canvas.height);
        }
        for(let i=0; i<=state.height; i++) {
            ctx.moveTo(0, i*state.scale);
            ctx.lineTo(canvas.width, i*state.scale);
        }
        ctx.stroke();

        if (state.mouseX >= 0 && state.mouseY >= 0 && state.mouseX < state.width && state.mouseY < state.height) {
            const offset = Math.floor(state.brushSize / 2);
            const drawX = (state.mouseX - offset) * state.scale;
            const drawY = (state.mouseY - offset) * state.scale;
            const drawSize = state.brushSize * state.scale;

            ctx.lineWidth = 2;
            
            if (state.tool === 'eraser') {
                ctx.strokeStyle = '#ff3333'; 
                ctx.strokeRect(drawX, drawY, drawSize, drawSize);
            } else if (state.tool === 'picker') {
                ctx.strokeStyle = '#fff';
                ctx.strokeRect(state.mouseX * state.scale, state.mouseY * state.scale, state.scale, state.scale); 
                ctx.fillStyle = state.color;
                ctx.fillRect(state.mouseX * state.scale + 2, state.mouseY * state.scale + 2, state.scale - 4, state.scale - 4);
            } else {
                ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                ctx.strokeRect(drawX, drawY, drawSize, drawSize);
                ctx.fillStyle = state.color + '80'; 
                ctx.fillRect(drawX, drawY, drawSize, drawSize);
            }
        }
    }

    function setupDragSource() {
        dragSource.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('type', 'current');
            e.dataTransfer.setData('color', state.color);
        });
    }

    function renderPalette() {
        const container = document.getElementById('palette-container');
        container.innerHTML = '';
        state.palette.forEach((color, idx) => {
            const div = document.createElement('div');
            div.className = 'swatch';
            div.style.backgroundColor = color;
            div.draggable = true;
            div.onclick = () => { updateColor(color); setTool('pen'); };
            div.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('type', 'swatch');
                e.dataTransfer.setData('index', idx);
            });
            div.addEventListener('dragover', (e) => { e.preventDefault(); div.classList.add('drag-over'); });
            div.addEventListener('dragleave', () => div.classList.remove('drag-over'));
            div.addEventListener('drop', (e) => {
                e.preventDefault(); div.classList.remove('drag-over');
                const type = e.dataTransfer.getData('type');
                if (type === 'current') {
                    state.palette[idx] = e.dataTransfer.getData('color');
                } else if (type === 'swatch') {
                    const fromIndex = parseInt(e.dataTransfer.getData('index'));
                    const movedColor = state.palette[fromIndex];
                    state.palette.splice(fromIndex, 1);
                    state.palette.splice(idx, 0, movedColor);
                }
                renderPalette();
            });
            container.appendChild(div);
        });
    }

    function updateColor(hex) {
        state.color = hex;
        if(document.activeElement !== hexInput) hexInput.value = hex;
        colorInput.value = hex;
        dragSource.style.backgroundColor = hex;
    }

    function parseColorString(str) {
        str = str.replace(/\s/g, '').toLowerCase();
        if (str.startsWith('#')) return str.length === 7 ? str : (str.length === 4 ? "#"+str[1]+str[1]+str[2]+str[2]+str[3]+str[3] : null);
        if (/^[0-9a-f]{6}$/.test(str)) return "#" + str;
        return null; 
    }

    function handleFileUpload(input) {
        if (input.files && input.files[0]) {
            const reader = new FileReader();
            reader.onload = (e) => importImageToCanvas(e.target.result);
            reader.readAsDataURL(input.files[0]);
        }
        input.value = ''; 
    }

    function handlePaste(e) {
        if (e.target.tagName === 'INPUT') return;
        const items = (e.clipboardData || e.originalEvent.clipboardData).items;
        for (let index in items) {
            const item = items[index];
            if (item.kind === 'file' && item.type.includes('image/')) {
                const blob = item.getAsFile();
                const reader = new FileReader();
                reader.onload = (event) => importImageToCanvas(event.target.result);
                reader.readAsDataURL(blob);
                const overlay = document.getElementById('paste-overlay');
                overlay.style.display = 'flex';
                setTimeout(() => overlay.style.display = 'none', 1000);
            }
        }
    }

    function importImageToCanvas(sourceUrl) {
        const img = new Image();
        img.onload = () => {
            const tempCvs = document.createElement('canvas');
            tempCvs.width = state.width; tempCvs.height = state.height;
            const tempCtx = tempCvs.getContext('2d');
            tempCtx.imageSmoothingEnabled = false; 
            tempCtx.drawImage(img, 0, 0, state.width, state.height);
            const newData = tempCtx.getImageData(0, 0, state.width, state.height);
            for (let i = 0; i < newData.data.length; i += 4) {
                const r = newData.data[i];
                if (r > 250 && newData.data[i+1] > 250 && newData.data[i+2] > 250) newData.data[i+3] = 0;
            }
            state.frames[state.currentFrameIndex] = newData;
            commitToHistory(); 
            renderEditor();
            updateFrameThumb(state.currentFrameIndex);
        };
        img.src = sourceUrl;
    }

    function resizeGrid() {
        const newSize = parseInt(document.getElementById('size-input').value);
        if(newSize < 8 || newSize > 64) return alert('Size must be between 8 and 64');
        if(!confirm("Changing size will clear current work. Continue?")) return;
        state.width = newSize; state.height = newSize;
        state.frames = []; state.currentFrameIndex = 0; state.history = []; state.historyIndex = -1;
        resizeCanvas(); addFrame();
    }

    function resizeCanvas() {
        canvas.width = state.width * state.scale;
        canvas.height = state.height * state.scale;
        previewCanvas.width = state.width * state.previewScale;
        previewCanvas.height = state.height * state.previewScale;
        previewCtx.imageSmoothingEnabled = false;
    }

    function clearCanvas() {
        const empty = new ImageData(state.width, state.height);
        state.frames[state.currentFrameIndex] = empty;
        commitToHistory();
        renderEditor();
        updateFrameThumb(state.currentFrameIndex);
    }

    function addFrame() {
        const empty = new ImageData(state.width, state.height);
        state.frames.push(empty);
        state.currentFrameIndex = state.frames.length - 1;
        commitToHistory(); 
        renderFrameList();
        renderEditor();
    }

    function duplicateFrame() {
        const current = state.frames[state.currentFrameIndex];
        const copy = new ImageData(new Uint8ClampedArray(current.data), state.width, state.height);
        state.frames.push(copy);
        state.currentFrameIndex = state.frames.length - 1;
        commitToHistory();
        renderFrameList();
        renderEditor();
    }

    function deleteFrame() {
        if(state.frames.length <= 1) return alert("Cannot delete the last frame.");
        state.frames.splice(state.currentFrameIndex, 1);
        if(state.currentFrameIndex >= state.frames.length) state.currentFrameIndex--;
        commitToHistory();
        renderFrameList();
        renderEditor();
    }

    function renderFrameList() {
        frameList.innerHTML = '';
        state.frames.forEach((frame, idx) => {
            const cvs = document.createElement('canvas');
            cvs.width = state.width; cvs.height = state.height;
            cvs.className = `frame-thumb ${idx === state.currentFrameIndex ? 'selected' : ''}`;
            const c = cvs.getContext('2d');
            c.putImageData(frame, 0, 0);
            cvs.title = `Frame ${idx + 1}`;
            cvs.onclick = () => {
                state.currentFrameIndex = idx;
                renderFrameList();
                renderEditor();
            };
            frameList.appendChild(cvs);
        });
    }

    function updateFrameThumb(idx) {
        if(frameList.children[idx]) {
            const ctx = frameList.children[idx].getContext('2d');
            ctx.clearRect(0,0,state.width, state.height);
            ctx.putImageData(state.frames[idx], 0, 0);
        }
    }

    let lastTime = 0; let animFrameIndex = 0;
    function startAnimationLoop() {
        function animate(timestamp) {
            if (state.isPlaying && state.frames.length > 0) {
                const interval = 1000 / state.fps;
                if (timestamp - lastTime > interval) {
                    lastTime = timestamp;
                    animFrameIndex = (animFrameIndex + 1) % state.frames.length;
                    previewCtx.clearRect(0,0,previewCanvas.width, previewCanvas.height);
                    const tCvs = document.createElement('canvas');
                    tCvs.width = state.width; tCvs.height = state.height;
                    const tCtx = tCvs.getContext('2d');
                    tCtx.putImageData(state.frames[animFrameIndex], 0, 0);
                    previewCtx.drawImage(tCvs, 0, 0, previewCanvas.width, previewCanvas.height);
                }
            }
            requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);
    }

    function setTool(name) {
        state.tool = name;
        document.querySelectorAll('.tool-group button').forEach(b => b.classList.remove('active'));
        if(name === 'pen') document.getElementById('btn-pen').classList.add('active');
        if(name === 'eraser') document.getElementById('btn-eraser').classList.add('active');
        if(name === 'picker') document.getElementById('btn-picker').classList.add('active');
        renderEditor(); 
    }

    function exportImage() {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = state.width; tempCanvas.height = state.height;
        tempCanvas.getContext('2d').putImageData(state.frames[state.currentFrameIndex], 0, 0);
        const link = document.createElement('a');
        link.download = 'sprite.png'; link.href = tempCanvas.toDataURL(); link.click();
    }

    function exportSpriteSheet() {
        const sheet = document.createElement('canvas');
        sheet.width = state.width * state.frames.length; sheet.height = state.height;
        const ctx = sheet.getContext('2d');
        state.frames.forEach((frame, i) => {
            const temp = document.createElement('canvas');
            temp.width = state.width; temp.height = state.height;
            temp.getContext('2d').putImageData(frame, 0, 0);
            ctx.drawImage(temp, i * state.width, 0);
        });
        const link = document.createElement('a');
        link.download = 'spritesheet.png'; link.href = sheet.toDataURL(); link.click();
    }

    init();

</script>
</body>
</html>
